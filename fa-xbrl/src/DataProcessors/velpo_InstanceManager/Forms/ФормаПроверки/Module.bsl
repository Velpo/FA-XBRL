///////////////////////////////////////////////////////////////////////////////////////////////////////
// FA-XBRL, Bookkeeping and XBRL proccessor
//
// @author: Paul Tarasov
//	@email: paul.tarasov@velpo.ru
// 
// Copyright (c) 2021 Paul Tarasov (Velpo)
///////////////////////////////////////////////////////////////////////////////////////////////////////

&НаСервере
Функция ВыгрузитьДанные()
	
	Obj = DataProcessors.velpo_InstanceFileUnload.Create();
	FillPropertyValues(Obj, Parameters, "BusinessUnit,Taxonomy,EntryPoint,Period");
	Obj.DebugMode = True;
	Obj.UnloadInstance();
	
	Return Obj.PathToServerTempFile;
	
КонецФункции

&НаСервере
Процедура ПроверитьНаСервере()
	
	EntryPointName = velpo_CommonFunctions.ObjectAttributeValue(Parameters.EntryPoint, "Name");
	
	// проучим файл
	ИмяФайлаОтчета = ВыгрузитьДанные();
	// получем таксоноимию и арелле
	КаталогФайлов = "c:\velpo\";
	ИмяКаталогаВалидатора = КаталогФайлов + "arelle";
	ИмяФайлаТаксономии = КаталогФайлов + "taxonomies\final_4_0\www.cbr.ru\xbrl\nso\ins\rep\2021-04-01\ep\" + EntryPointName + ".xsd";
	ИмяФайлаВалидации = ИмяКаталогаВалидатора + "\arelleCmdLine.exe";
	ИмяЛогФайла = ПолучитьИмяВременногоФайла(".xml");
	
	Шаблон = "{http://parameters}%1=%2";
	СтрокаПараметров = СтрШаблон(Шаблон, "refPeriodEnd", Формат(Parameters.Period, "ДФ=""гггг-ММ-дд"""));
	
	WScriptShell = новый COMОбъект("WScript.Shell");
	Скрипт = СтрШаблон("""%1"" -f ""%2"" -v --packages ""%3"" --parameters %4 --logFile ""%5"" --uiLang ru --labelLang ru-RU --calcDecimal --infoset --formula run --formulaUnsatisfiedAsser --logFormat ""%6""", ИмяФайлаВалидации, ИмяФайлаОтчета, ИмяФайлаТаксономии, СтрокаПараметров, ИмяЛогФайла, "%(messageCode)s DIVIDER %(message)s DIVIDER %(file)s DIVIDER %(refs)s DIVIDER %(levelname)s DIVIDER %(args)s ENDOFROW");
	WScriptShell.Run(Скрипт, 0, Истина);
	ФайлЛога = Новый Файл(ИмяЛогФайла);
	
	ТекстВалидации = "";
	Если ФайлЛога.Существует() Тогда
		ТекстовыйДокумент = новый ТекстовыйДокумент;
		ТекстовыйДокумент.Прочитать(ИмяЛогФайла, КодировкаТекста.UTF8);
		ТекстВалидации = ТекстовыйДокумент.ПолучитьТекст();
		РаспарситьЛогВалидации(ТекстВалидации);
	КонецЕсли;
			
	ТекстовыйДокумент = новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ИмяФайлаОтчета, КодировкаТекста.UTF8);
	ТекстОтчета = ТекстовыйДокумент.ПолучитьТекст();
	                                                                                                              
	ЭтаФорма.ТекстПротокола = ТекстВалидации + "<!--" + Символы.ПС + ТекстОтчета + Символы.ПС + "-->";

КонецПроцедуры // ПроверитьНаСервере()

&НаСервере
Процедура РаспарситьЛогВалидации(ТекстВалидации)
	
	ТаблицаОшибок.Очистить();
	ТаблицаПеременных.Очистить();
	ТаблицаПеременныхКопия =  ТаблицаПеременных.Выгрузить(, "Переменная,Элемент,Значение, НачалоПериода, КонецПериода");
	ТаблицаПеременныхКопия.Колонки.Добавить("QName");
	ТаблицаПеременныхКопия.Колонки.Добавить("contextRef");
	ТаблицаПеременныхКопия.Колонки.Добавить("startDate");
	ТаблицаПеременныхКопия.Колонки.Добавить("endDate");
	ТаблицаПеременныхКопия.Колонки.Добавить("instant");
		
	Если ТекстВалидации = "" Тогда
		Возврат;
	КонецЕсли;
	
	НомерОшибки = 1;
	КорневойУзел = ПрочитатьXMLИзСтроки(ТекстВалидации, "log");
	СтрокаТаблицыОшибок = Неопределено;
	Для каждого ЭлементEntry Из КорневойУзел.Элементы Цикл
		Если ЭлементEntry.Имя <> "entry" Тогда
			Продолжить;
		КонецЕсли;
		code = ПолучитьЗначениеАтрибута(ЭлементEntry, "code");
		Если СтрокаТаблицыОшибок <> Неопределено и code = "formula:assertionUnsatisfied" Тогда
			ТаблицаПеременныхКопия.Очистить();
			СтруктураПоискаТаблицаПеременныхКопия = новый Структура("QName,contextRef");
			Для каждого ЭлементПодчиненныйEntry Из ЭлементEntry.Элементы Цикл
				Если ЭлементПодчиненныйEntry.Имя = "message" Тогда
					factVarBindings = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйEntry, "factVarBindings");
					ОписаниеПеременных = СтрРазделить(factVarBindings, ",", Ложь);
					Для каждого ОписаниеПеременной Из ОписаниеПеременных Цикл
						ПозицияДвоеточия = СтрНайти(ОписаниеПеременной, ": ");
						Если ПозицияДвоеточия = Неопределено Тогда
							продолжить;
						КонецЕсли; 
						ОписаниеЗначенияПеременной = СокрЛП(Сред(ОписаниеПеременной, ПозицияДвоеточия + 1));
						Если ОписаниеЗначенияПеременной = "fallback [0]" Тогда
							Продолжить;
						КонецЕсли; 
						СтрокаТаблицыПеременныхКопия = ТаблицаПеременныхКопия.Добавить();
						СтрокаТаблицыПеременныхКопия.Переменная = СокрЛП(Лев(ОписаниеПеременной, ПозицияДвоеточия - 1));
					    Токены = РазложитьПоРазделителю(ОписаниеЗначенияПеременной, "context");
						Если Токены.Количество() > 1 Тогда
							СтрокаТаблицыПеременныхКопия.QName = СокрЛП(Токены[0]);
							СтрокаТаблицыПеременныхКопия.contextRef = СокрЛП(Токены[1]);
						КонецЕсли;
					КонецЦикла;
				ИначеЕсли ЭлементПодчиненныйEntry.Имя = "ref" Тогда
					СтрокаНужныхСвойст = "QName, contextRef, value, label, startDate, endDate, instant";
					НужныеСвойства = новый Структура(СтрокаНужныхСвойст);
					Для каждого ЭлементПодчиненныйRef Из ЭлементПодчиненныйEntry.Элементы Цикл
						Если ЭлементПодчиненныйRef.Имя <> "property" Тогда
							Продолжить;
						КонецЕсли;
						name = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйref, "name");
						value = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйref, "value");
						Если СтрНайти(СтрокаНужныхСвойст, name) <> 0 Тогда
							НужныеСвойства[name] = value;
						КонецЕсли; 
						Если name = "contextRef" Тогда
							Для каждого ЭлементПодчиненныйContext Из ЭлементПодчиненныйRef.Элементы Цикл
									Если ЭлементПодчиненныйContext.Имя <> "property" Тогда
										Продолжить;
									КонецЕсли;
									name = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйContext, "name");
									value = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйContext, "value");
				                    Если СтрНайти(СтрокаНужныхСвойст, name) <> 0 Тогда
										НужныеСвойства[name] = value;
									КонецЕсли; 
							КонецЦикла;
						КонецЕсли;
					КонецЦикла; 
					Если НЕ (ЗначениеЗаполнено(НужныеСвойства.QName) И ЗначениеЗаполнено(НужныеСвойства.contextRef))Тогда
						Продолжить;
					КонецЕсли; 
					ЗаполнитьЗначенияСвойств(СтруктураПоискаТаблицаПеременныхКопия, НужныеСвойства);
					СтрокиТаблицыПеременныхКопия = ТаблицаПеременныхКопия.НайтиСтроки(СтруктураПоискаТаблицаПеременныхКопия);
					Для каждого СтрокаТаблицыПеременныхКопия Из СтрокиТаблицыПеременныхКопия Цикл
						СтрокаТаблицыПеременныхКопия.Элемент =  НужныеСвойства.label;
						СтрокаТаблицыПеременныхКопия.Значение =  НужныеСвойства.value;
						Если ЗначениеЗаполнено(НужныеСвойства.instant) Тогда
							СтрокаТаблицыПеременныхКопия.КонецПериода = НужныеСвойства.instant;
						Иначе
							СтрокаТаблицыПеременныхКопия.НачалоПериода = НужныеСвойства.startDate;
							СтрокаТаблицыПеременныхКопия.КонецПериода = НужныеСвойства.endDate;
						КонецЕсли;
					КонецЦикла; 
				КонецЕсли;
			КонецЦикла;
			Для каждого СтрокаТаблицыПеременныхКопия Из ТаблицаПеременныхКопия Цикл
				СтрокаТаблицыПеременных = ТаблицаПеременных.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыПеременных, СтрокаТаблицыПеременныхКопия, "Переменная, Элемент, Значение, НачалоПериода, КонецПериода");
				СтрокаТаблицыПеременных.УникальныйИдентификатор = СтрокаТаблицыОшибок.УникальныйИдентификатор;
			КонецЦикла; 
			СтрокаТаблицыОшибок = Неопределено;
			Продолжить;
		КонецЕсли; 
		СтрокаТаблицыОшибок = Неопределено;
		Если СтрНачинаетсяС(code, "message:") Тогда
			СтрокаТаблицыОшибок = ТаблицаОшибок.Добавить();
			СтрокаТаблицыОшибок.УникальныйИдентификатор = новый УникальныйИдентификатор;
			СтрокаТаблицыОшибок.типсообщения = ПолучитьЗначениеАтрибута(ЭлементEntry, "level");
			Для каждого ЭлементПодчиненныйEntry Из ЭлементEntry.Элементы Цикл
				Если ЭлементПодчиненныйEntry.Имя = "message" Тогда
					Токены = РазложитьПоРазделителю(ЭлементПодчиненныйEntry.Текст, "DIVIDER");
					Если Токены.Количество() > 1 Тогда
						СтрокаТаблицыОшибок.сообщение = Токены[1];
					КонецЕсли;
				ИначеЕсли ЭлементПодчиненныйEntry.Имя = "ref" Тогда
					Для каждого ЭлементПодчиненныйref Из ЭлементПодчиненныйEntry.Элементы Цикл
						Если ЭлементПодчиненныйref.Имя = "property" Тогда
							name = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйref, "name");
							value = ПолучитьЗначениеАтрибута(ЭлементПодчиненныйref, "value");
							Если name = "id" Тогда
								СтрокаТаблицыОшибок.id = value;
								//Если СтрНачинаетсяС(value, "valueAssertion_FR_ORGINFO_nil") Тогда
								//	ТаблицаОшибок.Удалить(ТаблицаОшибок.Индекс(СтрокаТаблицыОшибок));
								//	СтрокаТаблицыОшибок = Неопределено;
								//	Прервать;
								//КонецЕсли;
							ИначеЕсли name = "test" Тогда
								СтрокаТаблицыОшибок.Выражение = value;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
			Если СтрокаТаблицыОшибок <> Неопределено Тогда
 				СтрокаТаблицыОшибок.НомерОшибки = НомерОшибки;
				НомерОшибки = НомерОшибки + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаСервере
Функция РазложитьПоРазделителю(Строка, Разделитель)
	Результат = новый Массив;
	Токены = СтрРазделить(Строка, " ", Ложь);
	Буфер = "";
	Для каждого Токен Из Токены Цикл
		Если Токен = Разделитель Тогда
			Результат.Добавить(Буфер);
			Буфер = "";
		Иначе
			Буфер = Буфер + ?(Буфер = "", "", " ") + Токен;
		КонецЕсли; 
	КонецЦикла; 
	Если Буфер <> "" Тогда
		Результат.Добавить(Буфер);
	КонецЕсли;
	Возврат Результат;

КонецФункции

&НаКлиенте
Процедура ПоказатьПротокол(Команда)

	ПараметрыЗаполнения = Новый Структура;
	ПараметрыЗаполнения.Вставить("ТекстПротокола", ЭтаФорма.ТекстПротокола);
	
	OpenForm("DataProcessor.InstanceManager.Form.ФормаТекстПротокола", ПараметрыЗаполнения, ThisForm);
		
КонецПроцедуры


&AtClient
Procedure ОткрытьПротоколCompletion(Val ТекстовыйДокумент) Export
	
	ClearMessages();
	
	If ТекстовыйДокумент <> Undefined Then 
		
		ЭтаФорма.ТекстПротокола = ТекстовыйДокумент.ПолучитьТекст();
		
		Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаОжидание;
		ЭтаФорма.ПодключитьОбработчикОжидания("ОткрытьПротоколНаКлиенте", 0.5, Истина);
		
	EndIf;
	
EndProcedure


&AtClient
Procedure ОткрытьПротоколSelectionCompletion(Val FileNameArray, Val AdditionalParameters) Export
	
	ClearMessages();
	
	If FileNameArray <> Undefined And FileNameArray.Count() > 0 Then 
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		Notification = New NotifyDescription("ОткрытьПротоколCompletion", ThisForm, ТекстовыйДокумент);
		ТекстовыйДокумент.BeginReading(Notification, FileNameArray[0]);
	EndIf;
	
EndProcedure

&НаКлиенте
Процедура ОткрытьПротокол(Команда)
	
	СтандартнаяОбработка = Ложь;
	
	DialogSettings = New Structure;
	DialogSettings.Insert("Filter",  velpo_StringFunctionsClientServer.SubstituteParametersInString(
			"%1|*.xml",
			NStr("en = 'XML file (*.xml)'; ru = 'XML файл (*.xml)'")));
		
	Notification = New NotifyDescription("ОткрытьПротоколSelectionCompletion", ThisForm);
	velpo_BusinessReportingClient.SelectTaxonomyFile(Notification, DialogSettings);


КонецПроцедуры

&НаКлиенте
Процедура ОткрытьПротоколНаКлиенте()
		
	РаспарситьЛогВалидации(ЭтаФорма.ТекстПротокола);
	
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаРезультат;

КонецПроцедуры // ОткрытьПротоколНаКлиенте()

&AtClient
Procedure СохранитьПротоколSelectionCompletion(Val FileNameArray, Val AdditionalParameters) Export
	
	ClearMessages();
	
	If FileNameArray <> Undefined And FileNameArray.Count() > 0 Then 
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ЭтаФорма.ТекстПротокола);
		ТекстовыйДокумент.Записать(FileNameArray[0], КодировкаТекста.UTF8);
		File = New File(FileNameArray[0]);
	 	BeginRunningApplication(New NotifyDescription, File.Path);
	EndIf;
		
EndProcedure

&НаКлиенте
Процедура СохранитьПротокол(Команда)

	СтандартнаяОбработка = Ложь;
	
	DialogSettings = New Structure;
	DialogSettings.Insert("Filter",  velpo_StringFunctionsClientServer.SubstituteParametersInString(
			"%1|*.xml",
			NStr("en = 'XML file (*.xml)'; ru = 'XML файл (*.xml)'")));
		
	Notification = New NotifyDescription("СохранитьПротоколSelectionCompletion", ThisForm);
	velpo_BusinessReportingClient.SelectTaxonomyFile(Notification, DialogSettings, FileDialogMode.Save);
	
КонецПроцедуры

&НаКлиенте
Процедура ПроверитьНаКлиенте()

	ПроверитьНаСервере();
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаРезультат;

КонецПроцедуры // ПроверитьНаКлиенте()

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	If Not ValueIsFilled(Parameters.BusinessUnit)
		OR Not ValueIsFilled(Parameters.Taxonomy)
		OR Not ValueIsFilled(Parameters.EntryPoint)
		OR Not ValueIsFilled(Parameters.Period) Then
		Отказ = True;
		СтандартнаяОбработка = False;
		Return;
	EndIf;
	
	Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаПустая;
	
КонецПроцедуры

&AtClient
Procedure OnOpen(Cancel)
	
	//Элементы.Страницы.ТекущаяСтраница = Элементы.СтраницаОжидание;
	//ЭтаФорма.ПодключитьОбработчикОжидания("ПроверитьНаКлиенте", 0.5, Истина);

EndProcedure

&НаКлиенте
Процедура ТаблицаОшибокПриАктивизацииСтроки(Элемент)
	
	Если Элементы.ТаблицаОшибок.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Элементы.ТаблицаПеременных.ОтборСтрок = новый ФиксированнаяСтруктура("УникальныйИдентификатор", Элементы.ТаблицаОшибок.ТекущиеДанные.УникальныйИдентификатор);
	
КонецПроцедуры





Функция СтрокаСодержитВариант(Строка, Вариант) Экспорт
	
	Возврат Найти("," + Строка + ",", "," + Вариант + ",") <> 0;
	
КонецФункции

//!!!!!!!!! при сравнениях на подобно спецсимволы портят все....
//2 варианта: либо эта функция, либо дублировать строки метаданных и в запросах искать по ним, а выбирать уже нужные.
//будет симбиоз. если задаем параметр то используем эту функцию, а для сравнения между метаданными будем использовать доп поля в метаданных.
Функция ПодготовитьПараметрПодобно(Знач Значение) Экспорт
	Значение = СтрЗаменить(Значение, "[", "/[");
	Значение = СтрЗаменить(Значение, "]", "/]");
	Значение = СтрЗаменить(Значение, "^", "/^");
	Значение = СтрЗаменить(Значение, "%", "/%");
	Значение = СтрЗаменить(Значение, "_", "/_");	
	Возврат Значение;
КонецФункции // ()


Функция ПрочитатьXMLВДерево(Чтение, ТребуемоеИмяУзла, ЗагружатьАтрибутыВМассив) Экспорт
	
	Корень = Неопределено;
	масУзлов = Новый Массив;
	Уровень = 0;
	
	Пока Чтение.Прочитать() Цикл
		Если Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Узел = Новый Структура;
			Узел.Вставить("Имя",            Чтение.Имя);
			Узел.Вставить("Атрибуты",       Новый Соответствие);
			Узел.Вставить("АтрибутыМассив", Новый Массив);
			Узел.Вставить("Элементы",       Новый Массив);
			Узел.Вставить("Текст",          "");
			
			Для Сч = 1 По Чтение.КоличествоАтрибутов() Цикл
				Узел.Атрибуты.Вставить(Чтение.ИмяАтрибута(Сч - 1), Чтение.ЗначениеАтрибута(Сч - 1));
				Если ЗагружатьАтрибутыВМассив Тогда
					Узел.АтрибутыМассив.Добавить(Новый Структура("Имя,Значение", Чтение.ИмяАтрибута(Сч - 1), Чтение.ЗначениеАтрибута(Сч - 1)));
				КонецЕсли;
			КонецЦикла;
			
			Если Уровень = 0 Тогда
				Если ТребуемоеИмяУзла <> Неопределено И Не СтрокаСодержитВариант(ТребуемоеИмяУзла, Узел.Имя) Тогда
					Чтение.Пропустить();
				Иначе
					Корень = Узел;	
				КонецЕсли;
			Иначе
				масУзлов[Уровень - 1].Элементы.Добавить(Узел);
			КонецЕсли;
			
			Уровень = Уровень + 1;
			Если Уровень > масУзлов.Количество() Тогда
				масУзлов.Добавить(Узел);
			Иначе
				масУзлов[Уровень - 1] = Узел;
			КонецЕсли;
			
		ИначеЕсли Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Уровень = Уровень - 1;
			
		ИначеЕсли Чтение.ТипУзла = ТипУзлаXML.Текст Тогда
			масУзлов[Уровень - 1].Текст = СокрЛП(Чтение.Значение);
			
		КонецЕсли;
	КонецЦикла;
	
	Чтение.Закрыть();
	
	Возврат Корень;
	
КонецФункции


Функция ПрочитатьXMLИзФайла(ИмяФайла, ТребуемоеИмяУзла = Неопределено, ЗагружатьАтрибутыВМассив = Ложь) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.ОткрытьФайл(ИмяФайла);
	Возврат ПрочитатьXMLВДерево(Чтение, ТребуемоеИмяУзла, ЗагружатьАтрибутыВМассив);
	
КонецФункции

Функция ПрочитатьXMLИзСтроки(Строка, ТребуемоеИмяУзла = Неопределено, ЗагружатьАтрибутыВМассив = Ложь) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Строка);
	Возврат ПрочитатьXMLВДерево(Чтение, ТребуемоеИмяУзла, ЗагружатьАтрибутыВМассив);
	
КонецФункции


Процедура НепредусмотренныйУзел(Узел, РодительскийУзел) Экспорт
	
	ВызватьИсключение СтрШаблон("Непредусмотренный узел %1 в узле: %2!", Узел.Имя, РодительскийУзел.Имя);
	
КонецПроцедуры

Процедура ПроверитьУзел(Узел, Простой, ЕстьТекст, ОбязательныеАтрибуты, НеобязательныеАтрибуты = "") Экспорт
	
	// Проверим, является ли узел простой
	Если ТипЗнч(Простой) = Тип("Булево") Тогда
		ПроверитьУзелНаПростоту(Узел, Простой);
	КонецЕсли;
	
	Если ТипЗнч(Простой) = Тип("Число") И Простой <> Узел.Элементы.Количество() Тогда
		ВызватьИсключение СтрШаблон("Узел %1 должен содержать подчиненных узлов: " + Простой + ", обнаружено: " + Узел.Элементы.Количество(), Узел.Имя);
	КонецЕсли;
	
	Если ТипЗнч(ЕстьТекст) = Тип("Булево") Тогда
	
		// Проверим наличие текста
		Если Не ЕстьТекст И Узел.Текст <> "" Тогда
			ВызватьИсключение СтрШаблон("Узел %1 не должен содержать текст", Узел.Имя);
		ИначеЕсли ЕстьТекст И Узел.Текст = "" Тогда
			ВызватьИсключение СтрШаблон("Узел %1 должен содержать текст", Узел.Имя);
		КонецЕсли;		
	
	КонецЕсли; 
	
	// Заданы ли обязательные атрибуты
	Для Каждого ИмяАтрибута Из СтрРазделить(ОбязательныеАтрибуты, ",", Ложь) Цикл 
		Если ПолучитьЗначениеАтрибута(Узел, ИмяАтрибута) = Неопределено Тогда
			ВызватьИсключение СтрШаблон("Не задан обязательный атрибут %1 в узле %2", ИмяАтрибута, Узел.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Нет ли лишних элементов
	Если НеобязательныеАтрибуты <> "*" Тогда
		Для Каждого Элемент Из Узел.Атрибуты Цикл
			ИмяАтрибута = Элемент.Ключ;
			Если Не СтрокаСодержитВариант(ОбязательныеАтрибуты, ИмяАтрибута) И Не СтрокаСодержитВариант(НеобязательныеАтрибуты, ИмяАтрибута) Тогда
				ВызватьИсключение СтрШаблон("Непредусмотренный атрибут %1 в узле %2", ИмяАтрибута, Узел.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьУзелНаПростоту(Узел, Значение = Истина) Экспорт
	Если Значение = Истина И Узел.Элементы.Количество() > 0 Тогда
		ВызватьИсключение СтрШаблон("Узел %1 должен быть простой, обнаружено подчиненных узлов: %2", Узел.Имя, Узел.Элементы.Количество());
	КонецЕсли;
	Если Значение = Ложь и Узел.Элементы.Количество() = 0 Тогда
		ВызватьИсключение СтрШаблон("Узел %1 не должен быть простым", Узел.Имя);
	КонецЕсли; 
КонецПроцедуры
 

Процедура ПроверитьЗначениеВУзле(Узел, ИмяАтрибута, ТребуемоеЗначение, УдалятьЗначение = Ложь) Экспорт
	
	Значение = ПолучитьЗначениеАтрибута(Узел, ИмяАтрибута);
	Если Значение <> ТребуемоеЗначение Тогда
		ВызватьИсключение СтрШаблон("В узле %1 для атрибута %2 + получено значение %3, ожидалось %4", Узел.Имя, ИмяАтрибута, Значение, ТребуемоеЗначение);
	КонецЕсли;
	Если УдалятьЗначение Тогда
		Узел.Атрибуты.Удалить(ИмяАтрибута);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьРавенствоДвухАтрибутов(Узел, ИмяАтрибута1, ИмяАтрибута2, УдалятьАтрибут2) Экспорт
	
	Значение1 = ПолучитьЗначениеАтрибута(Узел, ИмяАтрибута1);
	Значение2 = ПолучитьЗначениеАтрибута(Узел, ИмяАтрибута2);
	Если Значение1 <> Значение2 Тогда
		ВызватьИсключение СтрШаблон("В узле %1 ожидалось, что равны значения атрибутов %2 и %3,  %4 <> %5", Узел.Имя, ИмяАтрибута1, ИмяАтрибута2, Значение1, Значение2);
	КонецЕсли;
	Если УдалятьАтрибут2 Тогда
		Узел.Атрибуты.Удалить(ИмяАтрибута2);
	КонецЕсли;
	
КонецПроцедуры

Функция ПрочитатьТекстИзВложенногоУзла(Узел, ИмяВложенногоУзла) Экспорт

	ПроверитьУзел(Узел, 1, Ложь, "", "");
	Если Узел.Элементы[0].Имя <> ИмяВложенногоУзла Тогда
		ВызватьИсключение СтрШаблон("Узел %1 должен содержать вложенный узел %2, получен %3", Узел.Имя, ИмяВложенногоУзла, Узел.Элементы[0].Имя);
	КонецЕсли;
	ПроверитьУзел(Узел.Элементы[0], Истина, Истина, "", "");
	Возврат Узел.Элементы[0].Текст;
	
	
КонецФункции

Процедура ПроверитьИмяУзла(Узел, ТребуемоеИмя, РодительскийУзел = Неопределено, ПорядковыйНомер = Неопределено) Экспорт
	
	Если Узел.Имя <> ТребуемоеИмя Тогда
		ВызватьИсключение СтрШаблон("Непредусмотренный узел %1 в узле: %2" + ?(ПорядковыйНомер = Неопределено, "", " [" + ПорядковыйНомер + "]") + ", ожидался %3", Узел.Имя, ?(РодительскийУзел = Неопределено, "", РодительскийУзел.Имя), ТребуемоеИмя);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьЗначениеАтрибута(Узел, ИмяАтрибута) Экспорт
	Возврат Узел.Атрибуты.Получить(ИмяАтрибута);
КонецФункции

Функция ИмяАтрибутаПоЗначению(Узел, Значение, ИсключаемыеАтрибуты = Неопределено) Экспорт
	Для каждого КЗ Из Узел.Атрибуты Цикл
		Если ИсключаемыеАтрибуты <> Неопределено и ИсключаемыеАтрибуты.Найти(КЗ.Ключ) <> Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если КЗ.Значение = Значение Тогда
			Возврат КЗ.Ключ;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьИмяПространстваИмен(Узел, ИмяПространства) Экспорт

	ИсключаемыеАтрибуты = новый Массив;
	ИсключаемыеАтрибуты.Добавить("targetNamespace");
	
	ИмяПространства = ИмяАтрибутаПоЗначению(Узел, ИмяПространства, ИсключаемыеАтрибуты);
	Если ИмяПространства = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если Лев(ИмяПространства, 5) = "xmlns" Тогда
		ИмяПространства = Сред(ИмяПространства, 7);
	КонецЕсли;	
	Возврат ИмяПространства;
КонецФункции

Функция ПолучитьИмяЭлементаПространстваИмен(ИмяПространства, ИмяЭлемента) Экспорт
	Возврат ИмяПространства + ?(СтрДлина(ИмяПространства) <> 0, ":", "") + ИмяЭлемента;
КонецФункции
 
Функция ПолучитьСхему(ПространствоИмен = Неопределено, ПолноеИмяФайла = Неопределено) Экспорт
	Запрос = новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	XSDСхемы.Ссылка КАК Схема
	|ИЗ
	|	Справочник.XSDСхемы КАК XSDСхемы
	|ГДЕ Истина "
	+?(ПространствоИмен <> Неопределено," И XSDСхемы.namespace = &namespace","")
	+?(ПолноеИмяФайла <> Неопределено, " И XSDСхемы.ФайлТаксономии.ПолноеИмя = &ПолноеИмя", "");
	Запрос.УстановитьПараметр("namespace", ПространствоИмен);
	Запрос.УстановитьПараметр("ПолноеИмя", ПолноеИмяФайла);
	
	ТекстСообщенияОбОшибке = СтрШаблон("Не найдена схема %2 пространства имен %1.", ПространствоИмен, ПолноеИмяФайла);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		ВызватьИсключение ТекстСообщенияОбОшибке;
	КонецЕсли;
	Выборка = Результат.Выбрать();
	Если Выборка.Количество() <> 1 Тогда
		ВызватьИсключение ТекстСообщенияОбОшибке;
	КонецЕсли;
	Выборка.Следующий();
	Возврат Выборка.Схема;
КонецФункции // ()
  


